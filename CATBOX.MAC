	.TITLE	CATBOX - FIELD SERVICE AUTO. TEST BOX
	.SBTTL	************************************
	.SBTTL	*
	.SBTTL	*PROGRAMMER:  JOHN RAY
	.SBTTL	*
	.SBTTL	*CHECKER:
	.SBTTL	*
	.SBTTL	************************************
	.REPT 0
"COPYRIGHT 1980 ATARI, INC.  UNAUTHORIZED REPRODUCTION,
ADAPTATION, DISTRIBUTION, PERFORMANCE OR DISPLAY OF THIS
COMPUTER PROGRAM OR THE ASSOCIATED AUDIOVISUAL WORK IS
STRICTLY PROHIBITED.
	.ENDR
;
;DATE INITIATED:	2/25/80
;PROJECT CHARGE #:	28303
;
;DISK #:		4, B10
;
;HARDWARE REQUIREMENTS:	6502,6532,2K ROM
;
;PROGRAM DESCRIPTION:	THIS PROGRAM WILL BE USED IN THE TEST BOX TO READ
;			SWITCHES, WRITE TO LEDS, TAKE SIGNATURES AND EXERCISE
;			A GAME BOARD.
;
;FSATB=NO KEYBOARD
;FSATB2=KEYBOARD
;FSATB3=ADDRESS INCREMENT (PRE-PROD)
;FSTB3S=INCR BOUNCE FIX FOR PRE-PROD HARDWARE
;FSATB4=STATIC BUSSES
;FSATB5=256,1K CONTINUOUS
;CATBOX=PRODUCTION RELEASE
	.ASECT
	.RADIX	16
OPTION	=1
;OPTION	=1 FOR ROM
;OPTION	=3 FOR DEVSYS
CKSUM	=0CE			;CHECKSUM
	.PAGE
	.SBTTL	BASE PAGE ALLOCATION
;
;THE 6532 IS MAPPED TO 0000-1FFF.  IT USES 8 ADDRESS LINES OR 256 BYTES.
;00 TO 7F IS I/O AND TIMER.  80-FF IS RAM. (180-1FF IS DOUBLE MAPPED TO
;80-FF).
;
REG.A	=0000			;DATA, REGISTER A
DIR.A	=0001			;DIRECTION, REGISTER A (0=INPUT)
REG.B	=0002
DIR.B	=0003
TIMERIN	=0004			;READ TIMER, A3=1 TO ENABLE TIMER IRQ
				;(TIMERIN+8)
EDGEDET	=0004			;WRITE TO EDGE DETECT
				;	A1=1=ENABLE EDGE DETECT IRQ
				;	A0=1=POSITIVE EDGE DETECT
INTFLGS	=0005			;READ INTERRUPT FLAGS (RESETS FLAGS)
				;	D7=1=TIMER INTERRUPT
				;	D6=1=EDGE DETECT INTERRUPT
TIMEROUT=14			;WRITE TIMER
				;	A3=1=TO ENABLE TIMER IRQ
				;	A1,A0=TIMER INTERVAL
;RAM
	.=80
STATUS:	.BLKB	1		;D7=1=IRQ HAS OCCURED
LEDCNTR:.BLKB	1		;COUNTER SPECIFY WHICH LED TO OUTPUT TO
DATA:	.BLKB	1
ADRSL:	.BLKB	1
ADRSM:	.BLKB	1
DATA2:	.BLKB	1		;TO STORE BAD DATA FROM BOARD
ADRSL2:	.BLKB	1		;FOR WRITING
ADRSM2:	.BLKB	1
SHORTDEB:.BLKB	6
LONGDEB:.BLKB	6
TEMP1:	.BLKB	1
TEMP2:	.BLKB	1
DATABAD:.BLKB	1		;BIT 7=1 FOR COMPARE ERROR
SIGBAD:	.BLKB	1		;BIT 6=1 FOR UNSTABLE SIG.
BUSY:	.BLKB 1			;BIT 5=1 FOR STATIC OR CONTINUOUS
RDEB:	.BLKB	1		;CONT/SING SW DEBOUNCE
RSTAT:	.BLKB	1		;CONT/SING SW STATUS
SIGSTAT:.BLKB 	1		;BIT 4=1 FOR SIGNATURE ANALYZER MODE
SIGCNTR:.BLKB	1		;COUNTER FOR HOW LONG "UNSTABLE
				;SIGNATURE " LED IS ON
;
SETSTAT:.BLKB 1			;BIT 7=1 TO SET ADDRESS
				;BIT 6=1 TO SET DATA
ADDCNTR:.BLKB 1			;COUNTER TO SAY WHICH DIGIT OF
				;THE ADDRESS IS BEING SET
DATCNTR:.BLKB 1			;COUNTER TO SAY WHICH DIGIT OF
				;THE DATA IS BEING SET
COLOLD:	.BLKB 5			;STORES OLD VALUE OF COLUMN
COLSTAT:.BLKB 5			;STORES DEBOUNCED VALUE OF COLUMN
DEBFLAG:.BLKB 1			;SET DEBOUNCE FLAG
				;D7=1=DON'T ALOW
SIGSWSTAT:.BLKB 1		;SIG ANAL SWITCH STATUS.D7=1=R/W D7=0=SIG ANAL
	.=96			;DIAGNOSTIC RAM USE

ICOUNT:	.BLKB 1			;INTERRUPT COUNT
SECS:	.BLKB 1			;"SECONDS" COUNTER
TEST:	.BLKB 1			;TEST NUMBER (*2)
SWSTAT:	.BLKB 1			;EOR OF ALL SWITCHES
OLDSTAT:.BLKB 1			;OLD ONE
ZSEGS:	.BLKB 8			;SEGMENT DATA
ZDIGS:	.BLKB 8			;DIGIT DATA
	.SBTTL	OUTPUTS
;
GBCOUNT	=2000			;GAME/BOX COUNTER D3-D0
SEGS	=2800			;SEGMENTS D0-D7, A-G,DP
DIGITS	=3000			;D7,D6,D5-DIGIT SELECT
				;	0 NONE
				;	1 DATA1 (LEAST), DATA INCORRECT LED
				;	2 DATA2 (MOST), SIGNATURE UNSTABLE LED
				;	3 ADRS1 (LEAST)
				;	4 ADRS2
				;	5 ADRS3
				;	6 ADRS4 (MOST)
				;	7 DISCRETE LED'S
				;D4=1=SIG. ANAL. COUNTERS ENABLED
;
SIGRST	=3800			;RESET SIGNATURE SHIFT REGISTERS. D0=1=STATIC
	.SBTTL	INPUTS
;
				;ALL INPUTS ARE HIGH TRUE
SIGDONE	=4007			;D7=0=SIGNATURE DONE
TESTSW	=4006			;D7=1=SELF TEST
RDWRSW	=4005			;D7=1=READ,0=WRITE--READ/WRITE SW
SPARE	=4004			;D7=1=SPARE PIN GROUNDED (B2-15)

SIZE1K	=4003			;D7=1=SIZE=1K BYTE
SIZE1	=4002			;D7=1=SIZE=1 BYTE
DATASW	=4001			;D7=1=DATA IS DATA
ADRSBAR	=4000			;D7=1=DATA IS ADDRESS BAR
GMBXSW	=4008			;D4=1=GAME,0=BOX
SETADR	=4008			;D3=1=SET ADDRESS
SETDATA	=4008			;D2=1=SET DATA
SIGANAL	=4008			;D1=1=SIG. ANAL, 0=R/W
KBD	=4010			;START OF KEYBOARD
ALLKBD	=40F0			;D4-D1=ALL KEYBOARD KEYS--0=NONE PRESSED
STATIC	=4100		;D2=1=STATIC BUSSES
PULSE	=4100			;D1=1=PULSE BUSSES
	.PAGE

	.=6000			;PROGRAM SPACE 6000-67FF


;
;COPYRIGHT STUFF
	.BYTE 02,0BB,5A,30,50,0EE,3D,0A8	;MORSE CODE
;
	.ASCII/COPYRIGHT 1980, ATARI, INC./
	.SBTTL	MAIN PROGRAM LOOP
;
MAIN:
	LDA	STATUS		;CLEAR IRQ FLAG IN STATUS
	AND	I,7F
	STA	STATUS
	BIT	A,TESTSW
	BPL	40$
	JMP	PWRON
40$:	LDA	A,SIGANAL	;SIGANAL OR R/W?
	AND	I,2
	BEQ	20$		;R/W
	JSR	S.ANAL		;HANDLE SIG ANAL.
	JMP	10$
20$:	LDA	I,0		;R/W MODE
	STA	SIGSTAT		;SHUT OFF COUNTERS
	STA 	SIGBAD		;SHUT OFF SIG. UNSTABLE LED
	STA	SIGCNTR
	STA	BUSY			;SHUT OFF BUSY LED
	STA A,SIGRST		;SHUT OFF STATIC SIGNAL
	JSR	RD.WR
	JSR	STEADY
	JSR	SET		;HANDLE "SET" SWITCHES
10$:	LDA I,0			;WAIT FOR IRQ
	STA Z,TEMP1
30$:	LDA Z,STATUS
	BMI 50$			;BIT 7=1=IRQ OCCURRED
	INC Z,TEMP1		;NO IRQ--WAIT 256 LOOPS
	BNE 30$
	LDA I,47.		;TOO LONG--RESTART TIMER
	STA Z,TIMEROUT+2+8
	CLI
	BNE 30$			;BRA--GO WAIT AGAIN
50$:	JMP MAIN
	.PAGE
	.SBTTL	SIG. ANAL ROUTINE

;
;THIS ROUTINE IS ENTERED WHEN IN SIG. ANAL. MODE
;
S.ANAL:
	LDA	I,0
	STA	DATABAD		;TURN OFF "BAD DATA" LED
	STA	BUSY			;TURN OFF "BUSY" LED
	STA	DATA
	LDA	I,10		;TURN ON COUNTERS
	STA	SIGSTAT
	LDA	SIGCNTR		;SEE IF "UNSTABLE SIG" LED SHOULD BE ON
	BEQ	2$		;NO
	DEC	SIGCNTR		;YES
	LDA	I,40		;TURN ON LED
	STA	SIGBAD
	BNE	4$		;BRA
2$:	LDA	I,0		;TURN OFF LED
	STA	SIGBAD
4$:	BIT	A,SIGDONE	;IS SIG.ANAL. DONE?
	BPL	6$		;YES
	RTS			;NO-BYE!
6$:	LDX	I,40
	LDA	REG.B		;SIGNATURE SHOULD BE COMPARED
	CMP	ADRSL		;TO OLD SIGNATURE
	BEQ	10$
	STX	SIGCNTR		;DIFFERS, TURN ON ERROR LIGHT
10$:	STA	ADRSL
	LDA	REG.A
	CMP	ADRSM
	BEQ	20$
	STX	SIGCNTR
20$:	STA	ADRSM
	LDA I,0
	STA	A,SIGRST	;RESET SIG. ANAL
	RTS
	.PAGE
	.SBTTL	IRQ ROUTINE

;THIS ROUTINE IS ENTERED WHEN THE 6532 TIMER GENERATES AN IRQ.

IRQ:	PHA
	TXA
	PHA
	TYA
	PHA
	CLD
	LDA	STATUS		;STATUS BIT 7=1=IRQ OCCURED
	ORA	I,80
	STA	STATUS
	LDA	I,47.		;RESET TIMER
	STA	Z,TIMEROUT+2+8
	LDA A,TESTSW		;IN SELF TEST?
	BMI 40$			;YES, BYE
30$:	JSR	OUTPUT		;OUTPUT TO LED'S
40$:	PLA
	TAY
	PLA
	TAX
	PLA
	CLI
	RTI

	.SBTTL	POWER-ON ROUTINE

PWRON:	SEI
	CLD
	LDX	I,0FF
	TXS
	LDA	I,0		;CLEAR WORKING RAM (80-FF)
	BIT	A,TESTSW	;SELF TEST ON?
	BPL	10$		;NO
	JMP	STEST		;YES
10$:	STA	ZX,0
	DEX
	BMI	10$
	STA	A,DIGITS	;TURN OFF ADDRESS COUNTERS
	STA A,SIGRST		;TURN OFF STATIC SIGNAL
;
;SET UP 6532
	STA	Z,EDGEDET	;DISABLE EDGE DETECT IRQ
	STA	Z,DIR.A		;MAKE BOTH PORTS INPUTS
	STA	Z,DIR.B		;SET UP TIMER
	LDA	I,47.		;4MS= 47X64 COUNTS @ 750KHZ
	STA	Z,TIMEROUT+2+8	;64T, ENABLE TIMES IRQ
	CLI
	JMP	MAIN
	.PAGE
	.SBTTL	READ/WRITE ROUTINE

;
;THIS ROUTINE DEBOUNCES THE "PULSE" SWITCH;
;WRITES 1, 256, OR 1K BYTES; READS 1 BYTE AND
;COMPARES 256 OR 1K BYTES.
;
RD.WR:	LDA A,PULSE
	ROR			;MOVE D1 TO D7
	ROR
	ROR
	JSR RWDEB
	LDY I,0
	BIT RSTAT
	BMI 10$			;D7=1=CONTINUOUS
	BVS 20$			;D6=1=SINGLE
	RTS			;D7=D6=0=NONE

10$:	LDA I,20		;CONTINUOUS - TURN ON "LOOPING" LED
	STA BUSY
	STY RDEB			;CLEAR SWITCH COUNTER (SEE RWDEB)
	LDA ADRSL2		;GET ADDRESS BACK TO WHERE
	STA ADRSL		;IT SHOULD BE, (WAS ALTERED
	LDA ADRSM2		;DURING SINGLE.) (SINGLE
	STA ADRSM		;HAD TO HAPPEN.)
20$:	LDA RSTAT		;CLEAR " SINGLE" BIT
	AND I,0BF
	STA RSTAT
	STY DATABAD		;TURN OFF DATA INCORRECT FLAG
	LDA ADRSL		;SAVE STARTING ADDRESS
	STA ADRSL2
	LDA ADRSM
	STA ADRSM2
RDWRLP:
	LDA A,SIGANAL		;STILL IN R/W MODE?
	AND I,2
	BNE 5$			;NO
	BIT A,TESTSW		;SELF TEST ON?
	BPL 10$			;NO
5$:	RTS			;YES
10$:	STY TEMP1		;ASSUME SIZE=256
	STY TEMP2		;LOAD 100 INTO COUNTERS
	BIT A,SIZE1K
	BPL 20$
	LDA I,3			;SIZE ACTUALLY 1K
	STA TEMP2
20$:	BIT A,RDWRSW		;READ OR WRITE?
	BMI READ
	JMP WRITE
READ:	BIT A,SPARE		;READ - CHECK FOR JUMPER ON PCB.
	BPL 10$
	JMP SPECIAL			;GO TO CHECKSUM ROUTINE
10$:	BIT A,SIZE1		;1 BYTE?
	BPL 40$			;NO
	LDA I,0B		;YES-READ IT.
	SEI
	STA A,GBCOUNT		;5 CYCLES FOR (LDA NY,)
	LDA NY,ADRSL
	CLI
	STA DATA
	JMP RDDN
;256 OR 1K BYTES (READ & COMPARE)
40$:				;SEE WHAT KIND OF DATA TO COMPARE
	LDA A,DATASW
	BMI 60$			;DATA IS DATA
	LDA ADRSL
	BIT A,ADRSBAR
	BPL 50$			;DATA IS ADDRESS LOW
	EOR I,0FF		;DATA IS ADDRESS LOW BAR
50$:	STA DATA
60$:	LDA I,0B		;READ THE GAME DATA
	SEI
	STA A,GBCOUNT
	LDA NY,ADRSL
	CLI
	CMP DATA		;COMPARE GAME DATA TO BOX DATA
	BEQ 70$
	STA DATA2		;DONT'T MATCH-SET DATABAD FLAG
	LDA I,80
	STA DATABAD
	BMI RDERR		;BRA
70$:	INC ADRSL		;DATA MATCHES
	BNE 80$
	INC ADRSM		;UPDATE ADDRESS
80$:	DEC TEMP1
	BNE 40$
	LDA TEMP2		;DEC COUNTERS TILL BOTH=0
	BEQ RDDN
	DEC TEMP2
	JMP 40$
RDDN:	BIT RSTAT		;CONTINUOUS?
	BPL RDEX		;NO-BYE
	LDA A,PULSE		;PULSE SIWTCH STILL ON?
	AND I,2
	BEQ RDEX		;NO-BYE
	LDA ADRSL2		;YES-RESET ADDRESS COUNTERS
	STA ADRSL
	LDA ADRSM2
	STA ADRSM
	JMP RDWRLP		;DO IT AGAIN
RDERR:			;COMPARE ERROR
	LDX I,0			;WAIT HERE UNTIL PULSE SWITCH OFF
10$:	BIT A,TESTSW		;OR TEST SW ON
	BMI RDEX
	LDA A,SIGANAL		;OR SIGANAL ON.
	AND I,2
	BNE RDEX
	LDA A,PULSE		;DEBOUNCED PULSE
	AND I,2
	BNE RDERR
	DEX
	BNE 10$
RDEX:				;EXIT
	STY BUSY		;TURN OFF "LOOPING" LED
	RTS
;
;
WRITE:	BIT A,SIZE1		;1 BYTE?
	BPL 40$			;NO
	JSR WRITIT		;YES, WRITE IT OUT
	JMP WRDN
40$:				;WRITE 256 OR 1K BYTES
	LDA A,DATASW		;SEE WHAT KIND OF DATA TO OUTPUT
	BMI 60$			;DATA
	LDA ADRSL
	BIT A,ADRSBAR
	BPL 50$			;ADDRESS
	EOR I,0FF		;ADDRESS BAR
50$:	STA DATA
60$:	JSR WRITIT		;WRITE IT OUT
	DEC TEMP1		;DEC BOTH COUNTERS UNTIL=0
	BNE 80$
	LDA TEMP2
	BEQ WRDN
	DEC TEMP2
80$:	INC ADRSL		;INC ADDRESS IF DEC COUNTERS
	BNE 40$
	INC ADRSM
	JMP 40$
WRDN:	LDA ADRSL2		;RESTORE ADRS TO START
	STA ADRSL
	LDA ADRSM2
	STA ADRSM
	BIT RSTAT		;CONTINUOUS?
	BPL WREX		;NO-BYE
	LDA A,PULSE		;YES-PULSE STILL ON?
	AND I,2
	BEQ WREX		;NO
	JMP RDWRLP		;YES-DO IT AGAIN
WREX:	STY BUSY		;DONE, SHUT OFF "LOOPING" LED
	RTS			;GO HOME!
WRITIT:			;STORE IT OUT
	SEI
	LDA TIMERIN+8		;SAVE TIMER VALUE
	PHA
	LDA DATA
	LDX I,0A		;STA NY IS 6 CYCLES
	STX A,GBCOUNT
	STA NY,ADRSL
	PLA
	STA TIMEROUT+2+8	;RESTART TIMER
	CLI
	RTS
	.PAGE
	.SBTTL	SPECIAL CHECKSUM ROUTINE
	.REPT 0
	THIS ROUTINE CAN BE ENTERED BY GROUNDING
	B2-15 WHILE IN READ MODE.  THE PROGRAM
	WILL DISPLAY A CHECKSUM IN THE ADRESS
	DIGITS.  THE DATA DIGITS WILL DISSLAY A
	2, 4, OR 8 FOR THE SIZE OF THE ROM
	BEING CHECKSUMMED.
		SIZE SWITCH:		ROM SIZE:
			1		2KX8
			256		4KX8
			1K		8KX8

		DATA SWITCH		CHECKSUM TYPE
			DATA		ADD (2 BYTE)
			ADRS		ADD (1 BYTE, W/CARRY)
			ADRSBAR		XOR (1 BYTE)
	.ENDR
SPECIAL:	STY DATA		;CLEAR CHECKSUM BYTES
	STY DATA2
	LDA I,0F			;ASSUME SIZE=4K
	BIT A,SIZE1
	BPL 10$
	LDA I,7				;ACTUALLY 2K
	BNE 40$
10$:	BIT A,SIZE1K
	BPL 40$
	LDA I,1F			;ACTUALLY 8K
40$:	STA TEMP2
50$:	LDA I,0B			;READ THE ADDRESS
	SEI
	STA A,GBCOUNT
	LDA NY,ADRSL
	CLI
	BIT A,DATASW			;WHAT TYPE OF CHECKSUM?
	BPL 60$
	CLC				;2 BYTE ADD
	ADC DATA
	STA DATA
	TYA			;CLEAR A
	ADC DATA2
	STA DATA2
	JMP 90$
60$:	BIT A,ADRSBAR
	BMI 70$
	CLC				;1 BYTE ADD WITH CARRY
	ADC DATA
	ADC I,0
	STA DATA
	JMP 90$
70$:	EOR DATA			;XOR
	STA DATA
90$:	INC ADRSL			;NEXT ADDRESS
	BNE 100$
	INC ADRSM
100$:	DEC TEMP1
	BNE 50$
	LDA TEMP2
	BEQ SPDN
	DEC TEMP2
	JMP 50$
SPDN:	LDA DATA				;DISPLAY CHECKSUM IN ADDRESS
	STA ADRSL
	LDA DATA2
	STA ADRSM
	LDA I,2				;DISSLAY ROM SIZE INDATA
	BIT A,SIZE1
	BMI 10$
	ASL
	BIT A,SIZE1K
	BPL 10$
	ASL
10$:	STA DATA
	STY BUSY			;SHUT OFF "LOOPING" LED
	RTS
	.PAGE
	.SBTTL	PULSE SWITCH DEBOUNCE SUBROUTINE
;
RWDEB:
	BMI	RD1		;SWITCH ON
10$:	LDA	Z,RDEB		;SWITCH OFF
	AND	I,7F
	BNE	20$		;LOWER 7 BITS NOT EQUAL 0
	STA	Z,RDEB		;LOWER 7 BITS EQUAL 0, CLEAR BIT 7
	LDA	I,0
	STA	Z,RSTAT	;CLEAR READ STATUS
	RTS
20$:	DEC	Z,RDEB
	RTS
RD1:	LDA	Z,RDEB		;SWITCH ON
	CMP	I,0FF
	BNE	10$
	LDA	Z,RSTAT	;EQUAL TO FF, SET BIT 7 ON
	ORA	I,80		;(BIT 7 SAYS CONTINUOUS)
	STA	Z,RSTAT
	RTS
10$:	INC	Z,RDEB		;NOT EQUAL TO FF, INC IT
	LDA	Z,RDEB		;BIT 7 OFF
	CMP	I,10
	BNE	RD2		;LESS THAN 8, DON'T ONE SHOT
	ORA	I,40		;.GE. 8, ONE SHOT
	STA	Z,RDEB
	LDA	Z,RSTAT
	ORA	I,40		;BIT 6=ONE SHOT BIT
	STA	Z,RSTAT
RD2:	RTS
	.PAGE
	.SBTTL	STEADY ROUTINE
;
;THIS ROUTINE LATCHES THE ADDRESS AND DATA
;DISPLAYS ON THE ADDRESS AND DATA BUSSES.
;

STEADY:
	LDA A,STATIC		;IS "STATIC" PRESSED?
	AND I,4
	BNE 10$			;YES
	RTS			;NO
10$:	LDA I,0
	STA DATABAD		;SHUT OFF "BAD DATA" LED
	LDA A,RDWRSW		;READ OR WRITE?
	BPL WRSTDY		;WRITE
RDSTDY:	LDY I,0
10$:	LDA I,0B		;SET UP GAME/BOX CNTR
	SEI
	STA A,GBCOUNT
	LDA NY,ADRSL		;GET THE DATA
	CLI
	STA Z,DATA
	LDA I,20		;TURN BUSY "LED" ON
	STA BUSY
	LDA I,1			;TURN "STEADY" ON
	STA A,SIGRST
	BIT A,RDWRSW		;READ STILL ON?
	BPL 15$			;NO
	LDA A,STATIC		;SWITCH STILL ON?
	AND I,4
	BNE 10$			;YES
15$:	LDA I,0			;NO
	STA BUSY		;CLEAR BUSY LED
	STA A,SIGRST		;TURN "STEADY" OFF
	RTS
WRSTDY:	LDY I,0
	JSR WRITIT		;WRITE IT OUT.
	LDA I,20		;TURN ON BUSY LED
	STA BUSY
	LDA I,1			;TURN ON "STEADY" SIGNAL
	STA A,SIGRST
10$:	BIT A,RDWRSW		;WRITE STILL ON?
	BMI 15$			;NO
	LDA A,STATIC		;SWITCH STILL ON?
	AND I,4
	BNE 10$			;YES
15$:	LDA I,0			;NO
	STA BUSY		;CLEAR BUSY LED
	STA A,SIGRST		;TURN "STEADY" OFF
	RTS
	.PAGE
	.SBTTL	SET ROUTINE
;
;THIS ROUTINE IS USED TO INPUT THE ADDRESS +
;DATA FROM THE KEYBOARD
;SETSTAT:	D7=1=ADDRESS SHOULD BE SET
;		D6=1=DATA SHOULD BE SET
;ADDCNTR:	HOW MANY ADDRESS DIGITS ARE LEFT
;DATCNTR:	HOW MANY DATA DIGITS ARE LEFT
;
SET:
	LDA A,SETADR		;IS "SET ADDRESS" PUSHED?
	AND I,8			;D3
	BEQ 90$			;NO
	INC ADRSL		;YES INCREMENT ADDRESS
	BNE 4$
	INC ADRSM
4$:	LDA I,0
	STA DATABAD		;TURN OFF "BAD DATA" LED
5$:	LDX I,0
10$:	LDA A,SETADR		;STILL PUSHED?
	AND I,8
	BNE 5$
	DEX
	BNE 10$
90$:	LDA I,0			;INITIALIZE STATUS
	STA SETSTAT
	LDA A,ALLKBD		;ANY SWITCHES PRESSED?
	AND I,1E
	BEQ 95$			;NO
	LDA A,ALLKBD		;MAKE SURE
	AND I,1E
	BEQ 95$
	LDA I,80		;YES-SET ADDRESS
	STA SETSTAT
	LDA I,4			;INPUT 4 DIGITS
	STA ADDCNTR
	BNE 100$

95$:	LDA A,SETDATA		;NO KEYS. HOW ABOUT SETDATE?
	AND I,4			;D2
	BEQ 110$		;NO, BYE
	LDA I,40		;YES
	STA SETSTAT
	LDA I,2			;INPUT 2 DIGITS
	STA DATCNTR
100$:	JSR GETDIGS		;GET ALL OF THE DIGITS
101$:	LDX I,0
103$:	LDA A,ALLKBD		;WAIT UNTIL HIS FINGER IS
				;OFF THE LAST DIGIT
	AND I,1E
	BNE 101$
	DEX			;DEBOUNCE LOOP
	BNE 103$
110$:	RTS			;ELSE-DONE
	.PAGE
	.SBTTL	GET DIGITS SUBROUTINES
;CALLED BY SET--GETS ALL OF THE ADDRESS OR DATA DIGITS
;DEBFLAG:	D7=0=OK TO ACCEPT A DIGIT
;		D7=1=NOT OK CAUSE BUTTON STILL PRESSED
;
GETDIGS:
	LDA I,0
	STA DEBFLAG		;ALLOW DIGITS
	STA DATABAD		;TURN OFF "BAD DATA" LED
	LDX I,4
10$:	STA ZX,COLOLD		;CLEAR THE COLUMN DEBOUNCE BYTES
	STA ZX,COLSTAT
	DEX
	BPL 10$
	BIT SETSTAT		;GETTING ADDRESS OR DATA DIGITS?
	BPL 100$		;DATA
	LDY I,1			;ADDRESS
20$:	JSR GETNUM		;GET THE FIRST NUMBER
	ASL			;FIRST NUM IS MS NYBBLE
	ASL
	ASL
	ASL
	STA AY,ADRSL
	DEC ADDCNTR
	JSR GETNUM		;GET SECOND NUM
	ORA AY,ADRSL		;SECONT NUM IS LS NYBBLE
	STA AY,ADRSL
	DEC ADDCNTR
	DEY			;REPEAT FOR OTHER BYTE
	BPL 20$
	RTS
100$:	JSR GETNUM		;DATA
	ASL
	ASL
	ASL
	ASL
	STA DATA
	DEC DATCNTR
	JSR GETNUM
	ORA DATA
	STA DATA
	DEC DATCNTR
	RTS
	.PAGE
	.SBTTL	GET NUMBER SUBROUTINE
;THIS ROUTINE GETS 1 NUMBER FROM THE KEYBOARD
;IT IS CALLED BY GETDIGS.
;Y MUST BE RESTORED IF USED.
;A MUST CONTAIN THE NUMBER FROM THE KEYBOARD
;THIS ROUTINE CALLS RDKBD.RDKBD RETURNS
;WITH CARRY SET IF NO BUTTON WAS PRESSED.
;IF A BUTTON WAS PRESSED, THE CARRY WILL
;BE CLEARED AND THE VALUE OF THE BUTTON
;WILL BE IN A.
GETNUM:
	TYA			;SAVE Y
	PHA
10$:	JSR RDKBD		;READ CURRENT STATUS OF KBD
	PHA
	LDA A,SIGANAL		;DID WE CHANGE TO
	AND I,2			;SIG ANAL MODE?
	BEQ 20$			;NO
	JMP PWRON		;YES, BYE!
20$:	PLA
	LDY I,8			;DELAY LOOP
30$:	DEX
	BNE 30$
	DEY
	BNE 30$
	BIT DEBFLAG		;OK TO ACCEPT A NUMBER?
	BMI 10$			;NO
				;YES--DID WE GET A NUMBER?
	BCS 10$			;NO--TRY AGAIN
	TAX			;YES--SAVE IT
	LDA I,80		;SET DEBOUNCE FLAG
	STA DEBFLAG
	PLA			;RESTORE Y
	TAY
	TXA			;RESTORE NUMBER
	RTS			;RETURN WITH NUMBER IN A
	.PAGE
	.SBTTL	KEYBOARD SUBROUTINE
;CALLED BY GETNUM
;CARRY IS SET IF NO BUTTON PRESSED.
;CARRY IS CLEAR AND NUMBER IS IN A
;IF BUTTON IS PRESSED.
RDKBD:	LDA I,40		;TEMP1+2 FOR INDIRECT LOAD
	STA TEMP2		;KEYBOARD BASE IS 4000
	LDA I,80		;READ 4080,4040,4020,4010
	STA TEMP1
	LDX I,3			;4 COLUMNS
10$:	JSR GETCOL		;READ THIS COLUMN
	BNE 20$			;DATA WAS FOUND
	LSR TEMP1		;NO DATA FOUND, NEXT COLUMN
	DEX
	BPL 10$			;DO IT FOR ALL COLUMNS
	STA DEBFLAG		;A IS 0 HERE.
	SEC			;NO DATA ANYWHERE--SET
	RTS			;APPROPRIATE FLAGS + RETURN
20$:	LDY I,0FF		;THIS COLUMNS HAS DATA?
				;CONVERT IT TO KEY VALUE
30$:	LSR			;CONVERT BIT POSITION TO AN OFFSET
	INY
	BCC 30$			;KEEP GOING UNTIL GET A "1"
	TXA			;WORK ON COLUMN NUMBER
	ASL			;*4
	ASL
	STY TEMP1		;PUT OFFSET WHERE ITS USABLE
	ADC TEMP1		;CARRY IS CLEAR--GET TABLE OFFSET
	TAX
	LDA AX,KEYTAB		;GET THE KEY VALUE
	CLC			;STATUS TO SAY WE GOT SOMETHING
	RTS
;
	.SBTTL	GET COLUMN VALUE
;THIS SUBROUTINE READ THE VALUE OF THE CURRENT COLUMN
;X HAS THE COLUMN NUMBER (0-4)
;TEMP1+2 HAVE THE ADDRESS OF THE CURRENT COLUMN.
;RETURNS THE DEBOUNCED VALUE IN A.
;COLOLD(X) CONTAINS THE OLD VALUE OF THE COLUMN.
;COLSTAT(X) CONTAINS THE DEBOUNCED VALUE OF THE COLUMN.
;Y IS USED AND NOT RESTORED.
GETCOL:	LDY I,0
	LDA NY,TEMP1		;GET VALUE OF THIS COLUMN
	AND I,1E		;DATA IS IN D1-D4
	LSR			;PUT DATA IN D0-D3
	LDY ZX,COLOLD		;REPLACE OLD WITH NEW
	STA ZX,COLOLD		
	TYA			;FORCE A 1 IF READ
	AND ZX,COLOLD		;A 1 TWICE
	ORA ZX,COLSTAT
	STA ZX,COLSTAT
	TYA			;FORCE A 0 IF READ
	ORA ZX,COLOLD		;A 0 TWICE
	AND ZX,COLSTAT
	STA ZX,COLSTAT
	RTS

	.PAGE
	.SBTTL	OUTPUT ROUTINE

;THIS ROUTINE OUTPUTS TO THE LEDS

OUTPUT:	LDX	LEDCNTR		;GET NEXT DIGIT
	INX
	CPX	I,8		;1-7 ARE VALID
	BCC	10$
	LDX	I,1
10$:	STX	LEDCNTR
	LDA	I,0		;TURN OFF SEGMENTS TO
	STA	A,SEGS		;AVOID "SHADOWS"
20$:	TXA
	ASL			;PUT CURRENT DIGIT INTO
	ASL			;D7,D6,D5
	ASL
	ASL
	ASL
	ORA	SIGSTAT		;BIT 4=1 FOR SIG. ANAL
				;(TURNS ON COUNTERS)
	STA	A,DIGITS
	LDA	A,SIGANAL	;READ SIGANAL SW + PUT
	ROR			;INTO D7 OF SIGSWSTAT
	ROR
	ROR
	AND	I,80
	STA	SIGSWSTAT
	CPX	I,7		;IS THIS "SPECIAL" LED'S?
	BNE	25$		;NO
	LDA 	I,0		;YES
	ORA	DATABAD
	ORA	SIGBAD
	ORA	BUSY
	JMP	100$
25$:	DEX
	TXA
	LSR
	TAX
	BNE	28$		;X=0 MEANS DATA
	LDA	DATABAD		;SEE IF DATA IS BAD
	BPL	28$		;NO
	LDA	A,GMBXSW	;YES-SEE WHETHER GOOD OR BAD DATA
	AND	I,10		;SHOULD BE DISPLAYED
	BEQ	28$		;GOOD
	LDX	I,3		;BAD-POINT TO DATA2
28$:	LDA	ZX,DATA
	BCS	30$		;CARRY SET - MSB'S
	AND	I,0F		;CARRY CLEAR - LSB'S
	BPL	35$		;BRA
30$:	AND	I,0F0		;MSB'S
	LSR
	LSR
	LSR
	LSR
35$:	CMP	I,0A		;IS THIS AN "A" OR GREATER?
	BCC	40$		;NO
	BIT	A,SIGSWSTAT	;YES-SIG ANAL MODE?
	BPL	40$		;NO
	CLC			;YES-ADD 6 TO USE SPECIAL
	ADC	I,6		;CHARACTERS
40$:	TAY
	LDA	AY,LEDTAB	;CONVERT TO 7 SEGMENT
	LDX	LEDCNTR
	CPX	I,3		;DATA DIGITS?
	BCS 	60$		;NO
	BIT	A,SIGSWSTAT	;SIG. ANAL?
	BPL	60$		;NO
	LDA	I,00		;YES-BLANK DATA
60$:	BIT A,SIGSWSTAT		;SIG ANAL MODE?
	BMI 100$		;YES--OUTPUT
	CPX DATCNTR		;X HAS CURRENT DIGIT
	BEQ 90$			;DATCNTR IS 1 OR 2 IF INPUTING
				;DATA FROM KEYBOARD. BLANK DIGITS
	BCC 90$			;NOT ENTERED YET. I.E. X .LE. DATCNTR
	DEX			;NOW DO SAME FOR ADDRESS
	DEX
	BEQ 100$		;GOOD DATA-DISPLAY IT
	CPX ADDCNTR
	BEQ 90$
	BCS 100$
90$:	LDA I,0			;BLANK IT
100$:	STA A,SEGS
	RTS


	.PAGE
	.SBTTL	SELF TEST ROUTINE
;
;THIS ROUTINE OUTPUTS A CHARACTER IN THE LEAST SIGNIFICANT
;DATA DIGIT:
;
;0=RAM,ROM,TIMER OK
;1=RAM BAD
;2=ROM BAD
;3=TIMER BAD
;
;NOTE:TEST STOPS AT FIRST
;     CIRCUIT THAT IS BAD
;
STEST:
	LDA	I,20		;TURN ON DATA DIGIT
	STA	A,DIGITS	;TURN OFF NMI (THROUGH COUNTER)
	LDA	I,0		;BLANK DISPLAY
	STA	A,SEGS
	LDY	I,0		;OUTER LOOP COUNTER
5$:	LDX	I,0		;INNER LOOP INDEX
10$:	TYA			;DATA PATTERN
	STA	AX,80
	INY
	INX
	BPL	10$
	TXA			;ADD 80 TO X TO GET BACK TO
	CLC			;WHERE STARTED
	ADC	I,80
	TAX
	TYA			;SAME FOR Y
	CLC
	ADC	I,80
	TAY
20$:	TYA
	EOR	AX,80
	STA	AX,80		;SHOULD STORE BACK A ZERO
	BEQ	30$		;GOOD
	LDA	I,6		;RAM BAD, CODE=1
	BNE	DISPLAY		;BRA
30$:	INY
	INX
	BPL	20$
	TYA
	SEC			;GET BACK TO START+1
	ADC	I,80
	TAY
	BNE	5$		;DO IT FOR 00-FF
RGOOD:			;RAM GOOD, TRY ROM
	LDA	I,67		;CHECK TO 67FF
	STA	Z,TEMP1+1
	LDY 	I,7		;2K
	LDX	I,0
	TXA
	STA	Z,TEMP1
40$:	EOR	NX,TEMP1
	DEC	Z,TEMP1
	BNE	40$
	DEC	Z,TEMP1+1
	DEY
	BPL	40$
	STA	TEMP1		;**ONLY SO CAN SEE ON ANALYZER
	CMP	I,0		;IF RESULT=0, ROM GOOD
	BEQ	POK
	LDA	I,5B		;ROM BAD--CODE2
	BNE	DISPLAY		;BRA
POK:				;RAM,ROM GOOD. CHECK TIMER
	LDA INTFLGS		;CLEAR INTERRUPT FLAGS
	STA EDGEDET		;DISABLE EDGE DETECT IRQ
	LDA I,47.
	STA TIMEROUT+2+8	;START TIMER
	CLI
	LDA I,0
	STA TEMP1		;CLEAR COUNTER
10$:	INC TEMP1		;INC COUNTER
	LDA TEMP1
	BIT STATUS		;IRQ YET?
	BMI 30$			;YES
				;NO, HAVE WE WAITED TOO LONG?
	CMP I,0B0
	BCC 10$			;NO
	BCS 40$			;YES--ERROR
30$:				;IRQ OCCURRED--TOO QUICK?
	CMP I,09F
	BCS TOK			;NO--TIMER OK
40$:	LDA I,4F		;ERROR--DISPLAY "3"
	BNE DISPLAY
TOK:
	JMP DIAG		;EVERYTHING OK--GO TO DIAGNOSTICS
DISPLAY:
40$:	LDX I,5			;COUNTER SO DON'T BURN OUT LED
50$:	DEX
	BNE	60$		;NOT ON THIS TIME
	STA	A,SEGS		;ON THIS TIME, 
	BEQ	40$		;BRA
60$:	LDY I,0
	STY	A,SEGS		;NOT ON, BLANK DIGIT
	BIT	A,TESTSW	;SWITCH STILL ON?
	BMI	50$		;YES
	JMP	PWRON		;NO
	.PAGE
	.SBTTL	DIAGNOSTICS

;SELF TEST PASSED--RAM,ROM,TIMER ALL GOOD.
;NOW TEST LED'S+SWITCHES.
;	TEST		FUNCTION
;	 0		 ALL SEGMENT + ALL DIGITS ON
;	 1		 ALL SEGMENTS + DIGITS OFF
;	 2		 ALL SEGS ON, ROTATE DIGITS
;	 3		 ALL DIGS ON, ROTATE SEGS
;	 4		 ALL LEDS ON OR OFF-CHANGE
;				EACH TIME A SWITCH IS TOGGLED
;
;"ADDRESS INCR" OR "DATA SET" WILL BUMP THE TEST NUMBER
DIAG:				;ALL RAM IS CLEARED EXCEPT TEMP1,TEMP1+1
	LDA A,TESTSW
	BMI 10$
	JMP PWRON
10$:	LDY Z,TEST		;JUMP TO CORRECT TEST
	LDA AY,TESTAB
	STA Z,TEMP1
	LDA AY,TESTAB+1
	STA Z,TEMP1+1
	JMP N,TEMP1
RETX:	BIT Z,STATUS		;WAIT FOR IRQ
	BPL RETX
	LDA I,0
	STA Z,STATUS
	JSR SHOWIT
	LDA A,SETADR		;NEXT TEST?
	AND I,0C
	BEQ DIAG		;NO
	LDA I,0			;SHUT OFF SEGS
	STA A,SEGS
2$:	LDX I,0
5$:	LDA A,SETADR		;YES-WAIT FOR BUTTON NOT PRESSED
	AND I,0C
	BNE 2$
	DEX			;DELAY
	BNE 5$
	LDX Z,TEST
	INX
	INX
	CPX I,9
	BCC 10$
	LDX I,0
10$:	STX Z,TEST
	JMP DIAG
TESTAB:	.WORD TEST0
	.WORD TEST1
	.WORD TEST2
	.WORD TEST3
	.WORD TEST4

SHOWIT:				;UPDATE COUNTERS AND DISPLAY
	INC Z,ICOUNT		;UPDATE INTERRUPT COUNT
	BNE 10$
	INC Z,SECS		;UPDATE "SECONDS"
10$:	LDA Z,ICOUNT
	AND I,7			;UPDATE DISPLAY
	TAX
	LDA ZX,ZSEGS
	STA A,SEGS
	LDA ZX,ZDIGS
	ASL			;MOVE D0-D2 TO D5-D7
	ASL
	ASL
	ASL
	ASL
	STA A,DIGITS
	RTS
TEST0:	LDX I,7		;ALL SEGS + DIGS ON
10$:	LDA I,0FF
	STA ZX,ZSEGS
	TXA
	STA ZX,ZDIGS
	DEX
	BPL 10$
	JMP RETX
TEST1:	LDX I,7			;ALL SEGS + DIGS OFF
	LDA I,0
10$:	STA ZX,ZSEGS
	STA ZX,ZDIGS
	DEX
	BPL 10$
	JMP RETX
TEST2:	LDX I,7
10$:	LDA I,0FF
	STA Z,OLDSTAT		;FOR TEST 4
	STA ZX,ZSEGS		;ALL SEGS ON
	LDA I,0
	STA ZX,ZDIGS
	DEX
	BPL 10$
	LDA Z,SECS		;ONE ROTATING DIGIT ON
	AND I,7
	TAX
	STA ZX,ZDIGS
	JMP RETX
TEST3:	LDA Z,SECS		;CONVERT SECS TO BIT POS
	AND I,7
	TAX
	LDA I,0
	SEC
10$:	ROL
	DEX
	BPL 10$
	TAY
	LDX I,7
20$:	STY ZX,ZSEGS		;ROTATING SEG
	TXA
	STA ZX,ZDIGS		;ALL DIGS ON
	DEX
	BPL 20$
	JMP RETX
TEST4:
	LDA A,RDWRSW		;READ ALL D7'S
	EOR A,SIZE1K
	EOR A,SIZE1
	EOR A,ADRSBAR
	EOR A,DATASW
	AND I,80
	STA Z,SWSTAT
	LDA A,GMBXSW		;D4
	AND I,10
	EOR Z,SWSTAT
	STA Z,SWSTAT
	LDA A,STATIC		;D2
	AND I,4
	EOR Z,SWSTAT
	STA Z,SWSTAT
	LDA A,SIGANAL
	EOR A,PULSE
	AND I,2			;D1
	EOR Z,SWSTAT
	STA Z,SWSTAT
	LDA A,KBD		;D1-D4
	EOR A,KBD+10
	EOR A,KBD+30
	EOR A,KBD+70
	AND I,1E
	EOR Z,SWSTAT
	CMP Z,OLDSTAT		;SAME AS BEFORE?
	BEQ 40$			;YES-BYE!
	STA Z,OLDSTAT		;NO-KEEP IT + TOGGLE SEGS
	LDY I,87		;"7."
	LDA Z,ZSEGS
	BPL 10$
	LDY I,79		;"E"
10$:	LDX I,7
20$:	STY ZX,ZSEGS
	TXA
	STA ZX,ZDIGS
	DEX
	BPL 20$
40$:	JMP RETX

	.PAGE
	.SBTTL	TABLES

;LED TABLES: GIVES SEGMENTS FOR EACH CHARACTER

LEDTAB:	.BYTE	3F,06,5B,4F	;0-3
	.BYTE	66,6D,7D,07	;4-7
	.BYTE	7F,6F,0F7,0FC	;8-B.
	.BYTE	0B9,0DE,0F9,0F1	;C-F

				;SPECAIL CHARACTERS FOR SIG ANAL
	.BYTE	77		;A INSTEAD OF A.
	.BYTE 	39		;C INSTEAD OF B.
	.BYTE	71		;F INSTEAD OF C.
	.BYTE	76		;H INSTEAD OF D.
	.BYTE	73		;P INSTEAD OF E.
	.BYTE	3E		;U INSTEAD OF F.
	
;KEY TABLE:GIVES VALUE OF KEY FOR ROW & COLUMN
KEYTAB:
	.BYTE 0F,0B,7,3		;FIRST COLUMN(X=0) (D1-D4)
	.BYTE 0E,0A,6,2
	.BYTE 0D,9,5,1
	.BYTE 0C,8,4,0
	.NLIST	MEB
	.REPT	67FA-.
	.BYTE	0FF
	.ENDR
	.LIST	MEB


	.SBTTL	VECTORS

	.=67F9

	.BYTE	CKSUM
	.WORD	PWRON
	.WORD	PWRON
	.WORD	IRQ
	.IF	EQ,OPTION-3	;NEW DEV. SYS.
	.=0F7F8			;USER INTERRUPT VECTOR
	.WORD	IRQ
	.=0F7FC			;RESET VECTOR
	.WORD	PWRON
	.ENDC
	.END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       